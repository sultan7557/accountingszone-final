"use strict";
function isTypedObject(object) {
  return isRecord(object) && typeof object._type == "string";
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function parseBlocks({
  context,
  blocks,
  options
}) {
  return Array.isArray(blocks) ? blocks.flatMap((block) => {
    const parsedBlock = parseBlock({
      context,
      block,
      options
    });
    return parsedBlock ? [parsedBlock] : [];
  }) : [];
}
function parseBlock({
  context,
  block,
  options
}) {
  return parseTextBlock({
    block,
    context,
    options
  }) ?? parseBlockObject({
    blockObject: block,
    context,
    options
  });
}
function parseBlockObject({
  blockObject,
  context,
  options
}) {
  if (isTypedObject(blockObject) && !(blockObject._type === context.schema.block.name || blockObject._type === "block" || !context.schema.blockObjects.some(({
    name
  }) => name === blockObject._type)))
    return {
      ...blockObject,
      _key: options.refreshKeys ? context.keyGenerator() : typeof blockObject._key == "string" ? blockObject._key : context.keyGenerator()
    };
}
function isTextBlock(schema, block) {
  return parseTextBlock({
    block,
    context: {
      schema,
      keyGenerator: () => ""
    },
    options: {
      refreshKeys: !1
    }
  }) !== void 0;
}
function parseTextBlock({
  block,
  context,
  options
}) {
  if (!isTypedObject(block) || block._type !== context.schema.block.name)
    return;
  const _key = options.refreshKeys ? context.keyGenerator() : typeof block._key == "string" ? block._key : context.keyGenerator(), unparsedMarkDefs = Array.isArray(block.markDefs) ? block.markDefs : [], markDefKeyMap = /* @__PURE__ */ new Map(), markDefs = unparsedMarkDefs.flatMap((markDef) => {
    if (!isTypedObject(markDef))
      return [];
    if (typeof markDef._key != "string")
      return [];
    if (context.schema.annotations.some((annotation) => annotation.name === markDef._type)) {
      const _key2 = options.refreshKeys ? context.keyGenerator() : markDef._key;
      return markDefKeyMap.set(markDef._key, _key2), [{
        ...markDef,
        _key: _key2
      }];
    }
    return [];
  }), children = (Array.isArray(block.children) ? block.children : []).map((child) => parseSpan({
    span: child,
    context,
    markDefKeyMap,
    options
  }) ?? parseInlineObject({
    inlineObject: child,
    context,
    options
  })).filter((child) => child !== void 0), parsedBlock = {
    // Spread the entire block to allow custom properties on it
    ...block,
    _key,
    children: children.length > 0 ? children : [{
      _key: context.keyGenerator(),
      _type: context.schema.span.name,
      text: "",
      marks: []
    }],
    markDefs
  };
  if (typeof parsedBlock.style != "string" || !context.schema.styles.find((style) => style.value === block.style)) {
    const defaultStyle = context.schema.styles.at(0)?.value;
    defaultStyle !== void 0 ? parsedBlock.style = defaultStyle : delete parsedBlock.style;
  }
  return (typeof parsedBlock.listItem != "string" || !context.schema.lists.find((list) => list.value === block.listItem)) && delete parsedBlock.listItem, typeof parsedBlock.level != "number" && delete parsedBlock.level, parsedBlock;
}
function parseSpan({
  span,
  context,
  markDefKeyMap,
  options
}) {
  if (!isTypedObject(span) || span._type !== context.schema.span.name || span._type !== "span")
    return;
  const marks = (Array.isArray(span.marks) ? span.marks : []).flatMap((mark) => {
    if (typeof mark != "string")
      return [];
    const markDefKey = markDefKeyMap.get(mark);
    return markDefKey !== void 0 ? [markDefKey] : context.schema.decorators.some((decorator) => decorator.value === mark) ? [mark] : [];
  });
  return {
    // Spread the entire span to allow custom properties on it
    ...span,
    _type: "span",
    _key: options.refreshKeys ? context.keyGenerator() : typeof span._key == "string" ? span._key : context.keyGenerator(),
    text: typeof span.text == "string" ? span.text : "",
    marks
  };
}
function parseInlineObject({
  inlineObject,
  context,
  options
}) {
  if (isTypedObject(inlineObject) && !(inlineObject._type === context.schema.span.name || inlineObject._type === "span" || // Respect the schema definition and don't parse inline objects that are not defined
  !context.schema.inlineObjects.some(({
    name
  }) => name === inlineObject._type)))
    return {
      // Spread the entire inline object to allow custom properties on it
      ...inlineObject,
      _key: options.refreshKeys ? context.keyGenerator() : typeof inlineObject._key == "string" ? inlineObject._key : context.keyGenerator()
    };
}
exports.isTextBlock = isTextBlock;
exports.isTypedObject = isTypedObject;
exports.parseBlock = parseBlock;
exports.parseBlocks = parseBlocks;
//# sourceMappingURL=parse-blocks.cjs.map
