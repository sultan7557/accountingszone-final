{"version":3,"file":"index.js","sources":["../src/editor-event-listener.tsx","../src/internal-utils/compound-client-rect.ts","../src/internal-utils/drag-selection.ts","../src/internal-utils/event-position.ts","../src/internal-utils/selection.ts","../src/internal-utils/selection-elements.ts","../src/editor/components/DefaultObject.tsx","../src/editor/components/drop-indicator.tsx","../src/editor/components/Element.tsx","../src/editor/components/Leaf.tsx","../src/editor/plugins/createWithHotKeys.ts","../src/editor/range-decorations-machine.ts","../src/editor/Editable.tsx"],"sourcesContent":["import {useEffect} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {EditorEmittedEvent} from './editor/editor-machine'\nimport {useEditor} from './editor/editor-provider'\n\n/**\n * @public\n * @deprecated\n * This component has been renamed. Use `EventListenerPlugin` instead.\n *\n * ```\n * import {EventListenerPlugin} from '@portabletext/editor/plugins'\n * ```\n */\nexport function EditorEventListener(props: {\n  on: (event: EditorEmittedEvent) => void\n}) {\n  const editor = useEditor()\n  const on = useEffectEvent(props.on)\n\n  useEffect(() => {\n    const subscription = editor.on('*', on)\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [editor])\n\n  return null\n}\n","export function getCompoundClientRect(nodes: Array<Node>): DOMRect {\n  if (nodes.length === 0) {\n    return new DOMRect(0, 0, 0, 0)\n  }\n\n  const elements = nodes.filter((node) => node instanceof Element)\n\n  const firstRect = elements.at(0)?.getBoundingClientRect()\n\n  if (!firstRect) {\n    return new DOMRect(0, 0, 0, 0)\n  }\n\n  let left = firstRect.left\n  let top = firstRect.top\n  let right = firstRect.right\n  let bottom = firstRect.bottom\n\n  for (let i = 1; i < elements.length; i++) {\n    const rect = elements[i].getBoundingClientRect()\n    left = Math.min(left, rect.left)\n    top = Math.min(top, rect.top)\n    right = Math.max(right, rect.right)\n    bottom = Math.max(bottom, rect.bottom)\n  }\n\n  return new DOMRect(left, top, right - left, bottom - top)\n}\n","import type {EditorSnapshot} from '..'\nimport * as selectors from '../selectors'\nimport * as utils from '../utils'\nimport type {EventPosition} from './event-position'\n\n/**\n * Given the current editor `snapshot` and an `eventSelection` representing\n * where the drag event origins from, this function calculates the selection\n * in the editor that should be dragged.\n */\nexport function getDragSelection({\n  eventSelection,\n  snapshot,\n}: {\n  eventSelection: EventPosition['selection']\n  snapshot: EditorSnapshot\n}) {\n  let dragSelection = eventSelection\n\n  const draggedInlineObject = selectors.getFocusInlineObject({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n\n  if (draggedInlineObject) {\n    return dragSelection\n  }\n\n  const draggingCollapsedSelection = selectors.isSelectionCollapsed({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n  const draggedTextBlock = selectors.getFocusTextBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n  const draggedSpan = selectors.getFocusSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n\n  if (draggingCollapsedSelection && draggedTextBlock && draggedSpan) {\n    // Looks like we are dragging an empty span\n    // Let's drag the entire block instead\n    dragSelection = {\n      anchor: utils.getBlockStartPoint(draggedTextBlock),\n      focus: utils.getBlockEndPoint(draggedTextBlock),\n    }\n  }\n\n  const selectedBlocks = selectors.getSelectedBlocks(snapshot)\n\n  if (\n    snapshot.context.selection &&\n    selectors.isSelectionExpanded(snapshot) &&\n    selectedBlocks.length > 1\n  ) {\n    const selectionStartBlock = selectors.getSelectionStartBlock(snapshot)\n    const selectionEndBlock = selectors.getSelectionEndBlock(snapshot)\n\n    if (!selectionStartBlock || !selectionEndBlock) {\n      return dragSelection\n    }\n\n    const selectionStartPoint = utils.getBlockStartPoint(selectionStartBlock)\n    const selectionEndPoint = utils.getBlockEndPoint(selectionEndBlock)\n\n    const eventSelectionInsideBlocks = selectors.isOverlappingSelection(\n      eventSelection,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {anchor: selectionStartPoint, focus: selectionEndPoint},\n      },\n    })\n\n    if (eventSelectionInsideBlocks) {\n      dragSelection = {\n        anchor: selectionStartPoint,\n        focus: selectionEndPoint,\n      }\n    }\n  }\n\n  return dragSelection\n}\n","import {Editor, type BaseRange, type Node} from 'slate'\nimport {DOMEditor, isDOMNode} from 'slate-dom'\nimport type {EditorSchema, EditorSelection} from '..'\nimport type {EditorActor} from '../editor/editor-machine'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport * as utils from '../utils'\nimport {\n  getFirstBlock,\n  getLastBlock,\n  getNodeBlock,\n  slateRangeToSelection,\n} from './slate-utils'\n\nexport type EventPosition = {\n  block: 'start' | 'end'\n  /**\n   * Did the event origin from the editor DOM node itself or from a child node?\n   */\n  isEditor: boolean\n  selection: NonNullable<EditorSelection>\n}\nexport type EventPositionBlock = EventPosition['block']\n\nexport function getEventPosition({\n  editorActor,\n  slateEditor,\n  event,\n}: {\n  editorActor: EditorActor\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPosition | undefined {\n  if (editorActor.getSnapshot().matches({setup: 'setting up'})) {\n    return undefined\n  }\n\n  const node = getEventNode({slateEditor, event})\n\n  if (!node) {\n    return undefined\n  }\n\n  const block = getNodeBlock({\n    editor: slateEditor,\n    schema: editorActor.getSnapshot().context.schema,\n    node,\n  })\n\n  const positionBlock = getEventPositionBlock({node, slateEditor, event})\n  const selection = getEventSelection({\n    schema: editorActor.getSnapshot().context.schema,\n    slateEditor,\n    event,\n  })\n\n  if (block && positionBlock && !selection && !Editor.isEditor(node)) {\n    return {\n      block: positionBlock,\n      isEditor: false,\n      selection: {\n        anchor: utils.getBlockStartPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n        focus: utils.getBlockEndPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n      },\n    }\n  }\n\n  if (!positionBlock || !selection) {\n    return undefined\n  }\n\n  const focusBlockPath = selection.focus.path.at(0)\n  const focusBlockKey = utils.isKeyedSegment(focusBlockPath)\n    ? focusBlockPath._key\n    : undefined\n\n  if (!focusBlockKey) {\n    return undefined\n  }\n\n  if (\n    utils.isSelectionCollapsed(selection) &&\n    block &&\n    focusBlockKey !== block._key\n  ) {\n    return {\n      block: positionBlock,\n      isEditor: false,\n      selection: {\n        anchor: utils.getBlockStartPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n        focus: utils.getBlockEndPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n      },\n    }\n  }\n\n  return {\n    block: positionBlock,\n    isEditor: Editor.isEditor(node),\n    selection,\n  }\n}\n\nexport function getEventNode({\n  slateEditor,\n  event,\n}: {\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}) {\n  if (!DOMEditor.hasTarget(slateEditor, event.target)) {\n    return undefined\n  }\n\n  const node = DOMEditor.toSlateNode(slateEditor, event.target)\n\n  return node\n}\n\nfunction getEventPositionBlock({\n  node,\n  slateEditor,\n  event,\n}: {\n  node: Node\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPositionBlock | undefined {\n  const [firstBlock] = getFirstBlock({editor: slateEditor})\n\n  if (!firstBlock) {\n    return undefined\n  }\n\n  const firstBlockElement = DOMEditor.toDOMNode(slateEditor, firstBlock)\n  const firstBlockRect = firstBlockElement.getBoundingClientRect()\n\n  if (event.pageY < firstBlockRect.top) {\n    return 'start'\n  }\n\n  const [lastBlock] = getLastBlock({editor: slateEditor})\n\n  if (!lastBlock) {\n    return undefined\n  }\n\n  const lastBlockElement = DOMEditor.toDOMNode(slateEditor, lastBlock)\n  const lastBlockRef = lastBlockElement.getBoundingClientRect()\n\n  if (event.pageY > lastBlockRef.bottom) {\n    return 'end'\n  }\n\n  const element = DOMEditor.toDOMNode(slateEditor, node)\n  const elementRect = element.getBoundingClientRect()\n  const top = elementRect.top\n  const height = elementRect.height\n  const location = Math.abs(top - event.pageY)\n\n  return location < height / 2 ? 'start' : 'end'\n}\n\nexport function getEventSelection({\n  schema,\n  slateEditor,\n  event,\n}: {\n  schema: EditorSchema\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EditorSelection {\n  const range = getSlateRangeFromEvent(slateEditor, event)\n\n  const selection = range\n    ? slateRangeToSelection({\n        schema,\n        editor: slateEditor,\n        range,\n      })\n    : null\n\n  return selection\n}\n\nfunction getSlateRangeFromEvent(\n  editor: PortableTextSlateEditor,\n  event: DragEvent | MouseEvent,\n) {\n  if (!event.target) {\n    return undefined\n  }\n\n  if (!isDOMNode(event.target)) {\n    return undefined\n  }\n\n  const window = DOMEditor.getWindow(editor)\n\n  let domRange: Range | undefined\n\n  if (window.document.caretPositionFromPoint !== undefined) {\n    const position = window.document.caretPositionFromPoint(\n      event.clientX,\n      event.clientY,\n    )\n\n    if (position) {\n      try {\n        domRange = window.document.createRange()\n        domRange.setStart(position.offsetNode, position.offset)\n        domRange.setEnd(position.offsetNode, position.offset)\n      } catch {}\n    }\n  } else if (window.document.caretRangeFromPoint !== undefined) {\n    // Use WebKit-proprietary fallback method\n    domRange =\n      window.document.caretRangeFromPoint(event.clientX, event.clientY) ??\n      undefined\n  } else {\n    console.warn(\n      'Neither caretPositionFromPoint nor caretRangeFromPoint is supported',\n    )\n    return undefined\n  }\n\n  if (!domRange) {\n    return undefined\n  }\n\n  let range: BaseRange | undefined\n\n  try {\n    range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      // It can still throw even with this option set to true\n      suppressThrow: false,\n    })\n  } catch {}\n\n  return range\n}\n","import type {Path, PortableTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\nexport function normalizePoint(\n  point: EditorSelectionPoint,\n  value: PortableTextBlock[],\n): EditorSelectionPoint | null {\n  if (!point || !value) {\n    return null\n  }\n  const newPath: Path = []\n  let newOffset: number = point.offset || 0\n  const blockKey =\n    typeof point.path[0] === 'object' &&\n    '_key' in point.path[0] &&\n    point.path[0]._key\n  const childKey =\n    typeof point.path[2] === 'object' &&\n    '_key' in point.path[2] &&\n    point.path[2]._key\n  const block: PortableTextBlock | undefined = value.find(\n    (blk) => blk._key === blockKey,\n  )\n  if (block) {\n    newPath.push({_key: block._key})\n  } else {\n    return null\n  }\n  if (block && point.path[1] === 'children') {\n    if (\n      !block.children ||\n      (Array.isArray(block.children) && block.children.length === 0)\n    ) {\n      return null\n    }\n    const child =\n      Array.isArray(block.children) &&\n      block.children.find((cld) => cld._key === childKey)\n    if (child) {\n      newPath.push('children')\n      newPath.push({_key: child._key})\n      newOffset =\n        child.text && child.text.length >= point.offset\n          ? point.offset\n          : (child.text && child.text.length) || 0\n    } else {\n      return null\n    }\n  }\n  return {path: newPath, offset: newOffset}\n}\n\nexport function normalizeSelection(\n  selection: EditorSelection,\n  value: PortableTextBlock[] | undefined,\n): EditorSelection | null {\n  if (!selection || !value || value.length === 0) {\n    return null\n  }\n  let newAnchor: EditorSelectionPoint | null = null\n  let newFocus: EditorSelectionPoint | null = null\n  const {anchor, focus} = selection\n  if (\n    anchor &&\n    value.find((blk) => isEqual({_key: blk._key}, anchor.path[0]))\n  ) {\n    newAnchor = normalizePoint(anchor, value)\n  }\n  if (focus && value.find((blk) => isEqual({_key: blk._key}, focus.path[0]))) {\n    newFocus = normalizePoint(focus, value)\n  }\n  if (newAnchor && newFocus) {\n    return {anchor: newAnchor, focus: newFocus, backward: selection.backward}\n  }\n  return null\n}\n","import {Editor} from 'slate'\nimport {DOMEditor} from 'slate-dom'\nimport type {EditorSnapshot} from '..'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport {toSlateRange} from './ranges'\n\nexport type SelectionDomNodes = {\n  blockNodes: Array<Node>\n  childNodes: Array<Node>\n}\n\nexport function getSelectionDomNodes({\n  slateEditor,\n  snapshot,\n}: {\n  slateEditor: PortableTextSlateEditor\n  snapshot: EditorSnapshot\n}): SelectionDomNodes {\n  if (!snapshot.context.selection) {\n    return {\n      blockNodes: [],\n      childNodes: [],\n    }\n  }\n\n  const range = toSlateRange(snapshot.context.selection, slateEditor)\n\n  if (!range) {\n    return {\n      blockNodes: [],\n      childNodes: [],\n    }\n  }\n\n  const blockEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'highest',\n      match: (n) => !Editor.isEditor(n),\n    }),\n  )\n\n  const childEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'lowest',\n      match: (n) =>\n        (!Editor.isEditor(n) && slateEditor.isTextSpan(n)) ||\n        !slateEditor.isBlock(n),\n    }),\n  )\n\n  return {\n    blockNodes: blockEntries.map(([blockNode]) =>\n      DOMEditor.toDOMNode(slateEditor, blockNode),\n    ),\n    childNodes: childEntries.map(([childNode]) =>\n      DOMEditor.toDOMNode(slateEditor, childNode),\n    ),\n  }\n}\n","import type {PortableTextBlock, PortableTextChild} from '@sanity/types'\n\nexport function DefaultBlockObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <div style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </div>\n  )\n}\n\nexport function DefaultInlineObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <span style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </span>\n  )\n}\n","export function DropIndicator() {\n  return (\n    <div\n      contentEditable={false}\n      className=\"pt-drop-indicator\"\n      style={{\n        position: 'absolute',\n        width: '100%',\n        height: 1,\n        borderBottom: '1px solid currentColor',\n        zIndex: 5,\n      }}\n    >\n      <span />\n    </div>\n  )\n}\n","import type {\n  Path,\n  PortableTextChild,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type FunctionComponent,\n  type JSX,\n  type ReactElement,\n} from 'react'\nimport {Editor, Range, Element as SlateElement} from 'slate'\nimport {\n  ReactEditor,\n  useSelected,\n  useSlateStatic,\n  type RenderElementProps,\n} from 'slate-react'\nimport {defineBehavior} from '../../behaviors'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {EventPositionBlock} from '../../internal-utils/event-position'\nimport {fromSlateValue} from '../../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../../internal-utils/weakMaps'\nimport * as selectors from '../../selectors'\nimport type {\n  BlockRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderListItemFunction,\n  RenderStyleFunction,\n} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {DefaultBlockObject, DefaultInlineObject} from './DefaultObject'\nimport {DropIndicator} from './drop-indicator'\n\nconst debug = debugWithName('components:Element')\nconst debugRenders = false\nconst EMPTY_ANNOTATIONS: PortableTextObject[] = []\n\n/**\n * @internal\n */\nexport interface ElementProps {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement<any>\n  element: SlateElement\n  schemaTypes: PortableTextMemberSchemaTypes\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderListItem?: RenderListItemFunction\n  renderStyle?: RenderStyleFunction\n  spellCheck?: boolean\n}\n\nconst inlineBlockStyle = {display: 'inline-block'}\n\n/**\n * Renders Portable Text block and inline object nodes in Slate\n * @internal\n */\nexport const Element: FunctionComponent<ElementProps> = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck,\n}) => {\n  const editorActor = useContext(EditorActorContext)\n  const slateEditor = useSlateStatic()\n  const selected = useSelected()\n  const blockRef = useRef<HTMLDivElement | null>(null)\n  const inlineBlockObjectRef = useRef(null)\n  const focused =\n    (selected &&\n      slateEditor.selection &&\n      Range.isCollapsed(slateEditor.selection)) ||\n    false\n  const [dragPositionBlock, setDragPositionBlock] =\n    useState<EventPositionBlock>()\n\n  useEffect(() => {\n    const behavior = defineBehavior({\n      on: 'drag.dragover',\n      guard: ({snapshot, event}) => {\n        const dropFocusBlock = selectors.getFocusBlock({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: event.position.selection,\n          },\n        })\n\n        if (!dropFocusBlock || dropFocusBlock.node._key !== element._key) {\n          return false\n        }\n\n        const dragOrigin = snapshot.beta.internalDrag?.origin\n\n        if (!dragOrigin) {\n          return false\n        }\n\n        const draggedBlocks = selectors.getSelectedBlocks({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection,\n          },\n        })\n\n        if (\n          draggedBlocks.some(\n            (draggedBlock) => draggedBlock.node._key === element._key,\n          )\n        ) {\n          return false\n        }\n\n        const draggingEntireBlocks = selectors.isSelectingEntireBlocks({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection,\n          },\n        })\n\n        return draggingEntireBlocks\n      },\n      actions: [\n        ({event}) => [\n          {\n            type: 'effect',\n            effect: () => {\n              setDragPositionBlock(event.position.block)\n            },\n          },\n          {\n            type: 'noop',\n          },\n        ],\n      ],\n    })\n\n    editorActor.send({\n      type: 'add behavior',\n      behavior,\n    })\n\n    return () => {\n      editorActor.send({\n        type: 'remove behavior',\n        behavior,\n      })\n    }\n  }, [editorActor, element._key])\n\n  useEffect(() => {\n    const behavior = defineBehavior({\n      on: 'drag.*',\n      guard: ({event}) => {\n        return event.type !== 'drag.dragover'\n      },\n      actions: [\n        () => [\n          {\n            type: 'effect',\n            effect: () => {\n              setDragPositionBlock(undefined)\n            },\n          },\n        ],\n      ],\n    })\n\n    editorActor.send({\n      type: 'add behavior',\n      behavior,\n    })\n\n    return () => {\n      editorActor.send({\n        type: 'remove behavior',\n        behavior,\n      })\n    }\n  }, [editorActor])\n\n  const value = useMemo(\n    () =>\n      fromSlateValue(\n        [element],\n        schemaTypes.block.name,\n        KEY_TO_VALUE_ELEMENT.get(slateEditor),\n      )[0],\n    [slateEditor, element, schemaTypes.block.name],\n  )\n\n  let renderedBlock = children\n\n  let className: string | undefined\n\n  const blockPath: Path = useMemo(() => [{_key: element._key}], [element])\n\n  if (typeof element._type !== 'string') {\n    throw new Error(`Expected element to have a _type property`)\n  }\n\n  if (typeof element._key !== 'string') {\n    throw new Error(`Expected element to have a _key property`)\n  }\n\n  // Test for inline objects first\n  if (slateEditor.isInline(element)) {\n    const path = ReactEditor.findPath(slateEditor, element)\n    const [block] = Editor.node(slateEditor, path, {depth: 1})\n    const schemaType = schemaTypes.inlineObjects.find(\n      (_type) => _type.name === element._type,\n    )\n    if (!schemaType) {\n      throw new Error('Could not find type for inline block element')\n    }\n    if (SlateElement.isElement(block)) {\n      const elmPath: Path = [\n        {_key: block._key},\n        'children',\n        {_key: element._key},\n      ]\n      if (debugRenders) {\n        debug(`Render ${element._key} (inline object)`)\n      }\n      return (\n        <span {...attributes}>\n          {/* Note that children must follow immediately or cut and selections will not work properly in Chrome. */}\n          {children}\n          <span\n            draggable={!readOnly}\n            className=\"pt-inline-object\"\n            data-testid=\"pt-inline-object\"\n            ref={inlineBlockObjectRef}\n            key={element._key}\n            style={inlineBlockStyle}\n            contentEditable={false}\n          >\n            {renderChild &&\n              renderChild({\n                annotations: EMPTY_ANNOTATIONS, // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n                children: <DefaultInlineObject value={value} />,\n                editorElementRef: inlineBlockObjectRef,\n                focused,\n                path: elmPath,\n                schemaType,\n                selected,\n                type: schemaType,\n                value: value as PortableTextChild,\n              })}\n            {!renderChild && <DefaultInlineObject value={value} />}\n          </span>\n        </span>\n      )\n    }\n    throw new Error('Block not found!')\n  }\n\n  // If not inline, it's either a block (text) or a block object (non-text)\n  // NOTE: text blocks aren't draggable with DraggableBlock (yet?)\n  if (element._type === schemaTypes.block.name) {\n    className = `pt-block pt-text-block`\n    const isListItem = 'listItem' in element\n    if (debugRenders) {\n      debug(`Render ${element._key} (text block)`)\n    }\n    const style = ('style' in element && element.style) || 'normal'\n    className = `pt-block pt-text-block pt-text-block-style-${style}`\n    const blockStyleType = schemaTypes.styles.find(\n      (item) => item.value === style,\n    )\n    if (renderStyle && blockStyleType) {\n      renderedBlock = renderStyle({\n        block: element as PortableTextTextBlock,\n        children,\n        focused,\n        selected,\n        value: style,\n        path: blockPath,\n        schemaType: blockStyleType,\n        editorElementRef: blockRef,\n      })\n    }\n    let level: number | undefined\n\n    if (isListItem) {\n      if (typeof element.level === 'number') {\n        level = element.level\n      }\n      className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`\n    }\n\n    if (slateEditor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find(\n        (item) => item.value === element.listItem,\n      )\n      if (renderListItem && listType) {\n        renderedBlock = renderListItem({\n          block: value,\n          children: renderedBlock,\n          focused,\n          selected,\n          value: element.listItem,\n          path: blockPath,\n          schemaType: listType,\n          level: value.level || 1,\n          editorElementRef: blockRef,\n        })\n      }\n    }\n\n    const renderProps: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: renderedBlock,\n        editorElementRef: blockRef,\n        focused,\n        level,\n        listItem: isListItem ? element.listItem : undefined,\n        path: blockPath,\n        selected,\n        style,\n        schemaType: schemaTypes.block,\n        value,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaTypes.block\n        },\n      },\n    )\n\n    const propsOrDefaultRendered = renderBlock\n      ? renderBlock(renderProps as BlockRenderProps)\n      : children\n\n    return (\n      <div\n        key={element._key}\n        {...attributes}\n        className={className}\n        spellCheck={spellCheck}\n      >\n        {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n        <div ref={blockRef}>{propsOrDefaultRendered}</div>\n        {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n      </div>\n    )\n  }\n\n  const schemaType = schemaTypes.blockObjects.find(\n    (_type) => _type.name === element._type,\n  )\n\n  if (!schemaType) {\n    throw new Error(\n      `Could not find schema type for block element of _type ${element._type}`,\n    )\n  }\n\n  if (debugRenders) {\n    debug(`Render ${element._key} (object block)`)\n  }\n\n  className = 'pt-block pt-object-block'\n\n  const block = fromSlateValue(\n    [element],\n    schemaTypes.block.name,\n    KEY_TO_VALUE_ELEMENT.get(slateEditor),\n  )[0]\n\n  let renderedBlockFromProps: JSX.Element | undefined\n\n  if (renderBlock) {\n    const _props: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: <DefaultBlockObject value={value} />,\n        editorElementRef: blockRef,\n        focused,\n        path: blockPath,\n        schemaType,\n        selected,\n        value: block,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaType\n        },\n      },\n    )\n    renderedBlockFromProps = renderBlock(_props as BlockRenderProps)\n  }\n\n  return (\n    <div key={element._key} {...attributes} className={className}>\n      {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n      {children}\n      <div ref={blockRef} contentEditable={false} draggable={!readOnly}>\n        {renderedBlockFromProps ? (\n          renderedBlockFromProps\n        ) : (\n          <DefaultBlockObject value={value} />\n        )}\n      </div>\n      {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n    </div>\n  )\n}\n\nElement.displayName = 'Element'\n","import type {\n  Path,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {isEqual, uniq} from 'lodash'\nimport {\n  startTransition,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ReactElement,\n} from 'react'\nimport {Text} from 'slate'\nimport {useSelected, type RenderLeafProps} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {\n  BlockAnnotationRenderProps,\n  BlockChildRenderProps,\n  BlockDecoratorRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderAnnotationFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {usePortableTextEditor} from '../hooks/usePortableTextEditor'\nimport {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('components:Leaf')\n\nconst EMPTY_MARKS: string[] = []\n\n/**\n * @internal\n */\nexport interface LeafProps extends RenderLeafProps {\n  editorActor: EditorActor\n  children: ReactElement<any>\n  schemaTypes: PortableTextMemberSchemaTypes\n  renderAnnotation?: RenderAnnotationFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  readOnly: boolean\n}\n\n/**\n * Renders Portable Text span nodes in Slate\n * @internal\n */\nexport const Leaf = (props: LeafProps) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation,\n  } = props\n  const spanRef = useRef<HTMLElement>(null)\n  const portableTextEditor = usePortableTextEditor()\n  const blockSelected = useSelected()\n  const [focused, setFocused] = useState(false)\n  const [selected, setSelected] = useState(false)\n  const block = children.props.parent as PortableTextTextBlock | undefined\n  const path: Path = useMemo(\n    () => (block ? [{_key: block?._key}, 'children', {_key: leaf._key}] : []),\n    [block, leaf._key],\n  )\n  const decoratorValues = useMemo(\n    () => schemaTypes.decorators.map((dec) => dec.value),\n    [schemaTypes.decorators],\n  )\n  const marks: string[] = useMemo(\n    () =>\n      uniq(\n        (leaf.marks || EMPTY_MARKS).filter((mark) =>\n          decoratorValues.includes(mark),\n        ),\n      ),\n    [decoratorValues, leaf.marks],\n  )\n  const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS\n  const annotations = useMemo(\n    () =>\n      annotationMarks\n        .map(\n          (mark) =>\n            !decoratorValues.includes(mark) &&\n            block?.markDefs?.find((def) => def._key === mark),\n        )\n        .filter(Boolean) as PortableTextObject[],\n    [annotationMarks, block, decoratorValues],\n  )\n\n  const shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(false)\n      return\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor)\n    if (\n      sel &&\n      isEqual(sel.focus.path, path) &&\n      PortableTextEditor.isCollapsedSelection(portableTextEditor)\n    ) {\n      startTransition(() => {\n        setFocused(true)\n      })\n    }\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor])\n\n  // Function to check if this leaf is currently inside the user's text selection\n  const setSelectedFromRange = useCallback(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return\n    }\n    debug('Setting selection and focus from range')\n    const winSelection = window.getSelection()\n    if (!winSelection) {\n      setSelected(false)\n      return\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0)\n      if (spanRef.current && range.intersectsNode(spanRef.current)) {\n        setSelected(true)\n      } else {\n        setSelected(false)\n      }\n    } else {\n      setSelected(false)\n    }\n  }, [shouldTrackSelectionAndFocus])\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return undefined\n    }\n\n    const onBlur = editorActor.on('blurred', () => {\n      setFocused(false)\n      setSelected(false)\n    })\n\n    const onFocus = editorActor.on('focused', () => {\n      const sel = PortableTextEditor.getSelection(portableTextEditor)\n      if (\n        sel &&\n        isEqual(sel.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      }\n      setSelectedFromRange()\n    })\n\n    const onSelection = editorActor.on('selection', (event) => {\n      if (\n        event.selection &&\n        isEqual(event.selection.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      } else {\n        setFocused(false)\n      }\n      setSelectedFromRange()\n    })\n\n    return () => {\n      onBlur.unsubscribe()\n      onFocus.unsubscribe()\n      onSelection.unsubscribe()\n    }\n  }, [\n    editorActor,\n    path,\n    portableTextEditor,\n    setSelectedFromRange,\n    shouldTrackSelectionAndFocus,\n  ])\n\n  useEffect(() => setSelectedFromRange(), [setSelectedFromRange])\n\n  const content = useMemo(() => {\n    let returnedChildren = children\n    // Render text nodes\n    if (Text.isText(leaf) && leaf._type === schemaTypes.span.name) {\n      marks.forEach((mark) => {\n        const schemaType = schemaTypes.decorators.find(\n          (dec) => dec.value === mark,\n        )\n        if (schemaType && renderDecorator) {\n          const _props: Omit<BlockDecoratorRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                children: returnedChildren,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                selected,\n                schemaType,\n                value: mark,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaType\n                },\n              },\n            )\n          returnedChildren = renderDecorator(\n            _props as BlockDecoratorRenderProps,\n          )\n        }\n      })\n\n      if (block && annotations.length > 0) {\n        annotations.forEach((annotation) => {\n          const schemaType = schemaTypes.annotations.find(\n            (t) => t.name === annotation._type,\n          )\n          if (schemaType) {\n            if (renderAnnotation) {\n              const _props: Omit<BlockAnnotationRenderProps, 'type'> =\n                Object.defineProperty(\n                  {\n                    block,\n                    children: returnedChildren,\n                    editorElementRef: spanRef,\n                    focused,\n                    path,\n                    selected,\n                    schemaType,\n                    value: annotation,\n                  },\n                  'type',\n                  {\n                    enumerable: false,\n                    get() {\n                      console.warn(\n                        \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                      )\n                      return schemaType\n                    },\n                  },\n                )\n\n              returnedChildren = (\n                <span ref={spanRef}>\n                  {renderAnnotation(_props as BlockAnnotationRenderProps)}\n                </span>\n              )\n            } else {\n              returnedChildren = <span ref={spanRef}>{returnedChildren}</span>\n            }\n          }\n        })\n      }\n      if (block && renderChild) {\n        const child = block.children.find((_child) => _child._key === leaf._key) // Ensure object equality\n        if (child) {\n          const defaultRendered = <>{returnedChildren}</>\n          const _props: Omit<BlockChildRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                annotations,\n                children: defaultRendered,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                schemaType: schemaTypes.span,\n                selected,\n                value: child,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaTypes.span\n                },\n              },\n            )\n          returnedChildren = renderChild(_props as BlockChildRenderProps)\n        }\n      }\n    }\n    return returnedChildren\n  }, [\n    annotations,\n    block,\n    children,\n    focused,\n    leaf,\n    marks,\n    path,\n    renderAnnotation,\n    renderChild,\n    renderDecorator,\n    schemaTypes.annotations,\n    schemaTypes.decorators,\n    schemaTypes.span,\n    selected,\n  ])\n  return useMemo(\n    () => (\n      <span key={leaf._key} {...attributes} ref={spanRef}>\n        {content}\n      </span>\n    ),\n    [leaf, attributes, content],\n  )\n}\n\nLeaf.displayName = 'Leaf'\n","import type {KeyboardEvent} from 'react'\nimport type {ReactEditor} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {isHotkey} from '../../internal-utils/is-hotkey'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {HotkeyOptions} from '../../types/options'\nimport type {EditorActor} from '../editor-machine'\nimport type {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('plugin:withHotKeys')\n\n/**\n * This plugin takes care of all hotkeys in the editor\n *\n */\nexport function createWithHotkeys(\n  editorActor: EditorActor,\n  portableTextEditor: PortableTextEditor,\n  hotkeysFromOptions?: HotkeyOptions,\n): (editor: PortableTextSlateEditor & ReactEditor) => any {\n  const reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end']\n  const activeHotkeys = hotkeysFromOptions ?? {}\n  return function withHotKeys(editor: PortableTextSlateEditor & ReactEditor) {\n    editor.pteWithHotKeys = (event: KeyboardEvent<HTMLDivElement>): void => {\n      // Wire up custom marks hotkeys\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === 'marks') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault()\n              const possibleMark = activeHotkeys[cat]\n              if (possibleMark) {\n                const mark = possibleMark[hotkey]\n                debug(`HotKey ${hotkey} to toggle ${mark}`)\n                editorActor.send({\n                  type: 'behavior event',\n                  behaviorEvent: {\n                    type: 'decorator.toggle',\n                    decorator: mark,\n                  },\n                  editor,\n                })\n              }\n            }\n          }\n        }\n        if (cat === 'custom') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat]\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey]\n                command(event, portableTextEditor)\n              }\n            }\n          }\n        }\n      })\n    }\n    return editor\n  }\n}\n","import {isEqual} from 'lodash'\nimport {\n  Element,\n  Path,\n  Range,\n  type BaseRange,\n  type NodeEntry,\n  type Operation,\n} from 'slate'\nimport {\n  and,\n  assertEvent,\n  assign,\n  fromCallback,\n  setup,\n  type ActorRefFrom,\n  type AnyEventObject,\n  type CallbackLogicFunction,\n} from 'xstate'\nimport type {EditorSchema} from '..'\nimport {moveRangeByOperation, toSlateRange} from '../internal-utils/ranges'\nimport {slateRangeToSelection} from '../internal-utils/slate-utils'\nimport {isEqualToEmptyEditor} from '../internal-utils/values'\nimport type {PortableTextSlateEditor, RangeDecoration} from '../types/editor'\n\nconst slateOperationCallback: CallbackLogicFunction<\n  AnyEventObject,\n  {type: 'slate operation'; operation: Operation},\n  {slateEditor: PortableTextSlateEditor}\n> = ({input, sendBack}) => {\n  const originalApply = input.slateEditor.apply\n\n  input.slateEditor.apply = (op) => {\n    if (op.type !== 'set_selection') {\n      sendBack({type: 'slate operation', operation: op})\n    }\n\n    originalApply(op)\n  }\n\n  return () => {\n    input.slateEditor.apply = originalApply\n  }\n}\n\ntype DecoratedRange = BaseRange & {rangeDecoration: RangeDecoration}\n\nexport const rangeDecorationsMachine = setup({\n  types: {\n    context: {} as {\n      decoratedRanges: Array<DecoratedRange>\n      pendingRangeDecorations: Array<RangeDecoration>\n      skipSetup: boolean\n      readOnly: boolean\n      schema: EditorSchema\n      slateEditor: PortableTextSlateEditor\n      updateCount: number\n    },\n    input: {} as {\n      rangeDecorations: Array<RangeDecoration>\n      readOnly: boolean\n      schema: EditorSchema\n      skipSetup: boolean\n      slateEditor: PortableTextSlateEditor\n    },\n    events: {} as\n      | {\n          type: 'ready'\n        }\n      | {\n          type: 'range decorations updated'\n          rangeDecorations: Array<RangeDecoration>\n        }\n      | {\n          type: 'slate operation'\n          operation: Operation\n        }\n      | {\n          type: 'update read only'\n          readOnly: boolean\n        },\n  },\n  actions: {\n    'update pending range decorations': assign({\n      pendingRangeDecorations: ({event}) => {\n        assertEvent(event, 'range decorations updated')\n\n        return event.rangeDecorations\n      },\n    }),\n    'set up initial range decorations': assign({\n      decoratedRanges: ({context, event}) => {\n        assertEvent(event, 'ready')\n\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const rangeDecoration of context.pendingRangeDecorations) {\n          const slateRange = toSlateRange(\n            rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          rangeDecorationState.push({\n            rangeDecoration,\n            ...slateRange,\n          })\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'update range decorations': assign({\n      decoratedRanges: ({context, event}) => {\n        assertEvent(event, 'range decorations updated')\n\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const rangeDecoration of event.rangeDecorations) {\n          const slateRange = toSlateRange(\n            rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          rangeDecorationState.push({\n            rangeDecoration,\n            ...slateRange,\n          })\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'move range decorations': assign({\n      decoratedRanges: ({context, event}) => {\n        assertEvent(event, 'slate operation')\n\n        const rangeDecorationState: Array<DecoratedRange> = []\n\n        for (const decoratedRange of context.decoratedRanges) {\n          const slateRange = toSlateRange(\n            decoratedRange.rangeDecoration.selection,\n            context.slateEditor,\n          )\n\n          if (!Range.isRange(slateRange)) {\n            decoratedRange.rangeDecoration.onMoved?.({\n              newSelection: null,\n              rangeDecoration: decoratedRange.rangeDecoration,\n              origin: 'local',\n            })\n            continue\n          }\n\n          let newRange: BaseRange | null | undefined\n\n          newRange = moveRangeByOperation(slateRange, event.operation)\n          if (\n            (newRange && newRange !== slateRange) ||\n            (newRange === null && slateRange)\n          ) {\n            const newRangeSelection = newRange\n              ? slateRangeToSelection({\n                  schema: context.schema,\n                  editor: context.slateEditor,\n                  range: newRange,\n                })\n              : null\n\n            decoratedRange.rangeDecoration.onMoved?.({\n              newSelection: newRangeSelection,\n              rangeDecoration: decoratedRange.rangeDecoration,\n              origin: 'local',\n            })\n          }\n\n          // If the newRange is null, it means that the range is not valid anymore and should be removed\n          // If it's undefined, it means that the slateRange is still valid and should be kept\n          if (newRange !== null) {\n            rangeDecorationState.push({\n              ...(newRange || slateRange),\n              rangeDecoration: {\n                ...decoratedRange.rangeDecoration,\n                selection: slateRangeToSelection({\n                  schema: context.schema,\n                  editor: context.slateEditor,\n                  range: newRange,\n                }),\n              },\n            })\n          }\n        }\n\n        return rangeDecorationState\n      },\n    }),\n    'assign readOnly': assign({\n      readOnly: ({event}) => {\n        assertEvent(event, 'update read only')\n        return event.readOnly\n      },\n    }),\n    'increment update count': assign({\n      updateCount: ({context}) => {\n        return context.updateCount + 1\n      },\n    }),\n  },\n  actors: {\n    'slate operation listener': fromCallback(slateOperationCallback),\n  },\n  guards: {\n    'has pending range decorations': ({context}) =>\n      context.pendingRangeDecorations.length > 0,\n    'has range decorations': ({context}) => context.decoratedRanges.length > 0,\n    'has different decorations': ({context, event}) => {\n      assertEvent(event, 'range decorations updated')\n\n      const existingRangeDecorations = context.decoratedRanges.map(\n        (decoratedRange) => ({\n          anchor: decoratedRange.rangeDecoration.selection?.anchor,\n          focus: decoratedRange.rangeDecoration.selection?.focus,\n        }),\n      )\n\n      const newRangeDecorations = event.rangeDecorations.map(\n        (rangeDecoration) => ({\n          anchor: rangeDecoration.selection?.anchor,\n          focus: rangeDecoration.selection?.focus,\n        }),\n      )\n\n      const different = !isEqual(existingRangeDecorations, newRangeDecorations)\n\n      return different\n    },\n    'not read only': ({context}) => !context.readOnly,\n    'should skip setup': ({context}) => context.skipSetup,\n  },\n}).createMachine({\n  id: 'range decorations',\n  context: ({input}) => ({\n    readOnly: input.readOnly,\n    pendingRangeDecorations: input.rangeDecorations,\n    decoratedRanges: [],\n    skipSetup: input.skipSetup,\n    schema: input.schema,\n    slateEditor: input.slateEditor,\n    updateCount: 0,\n  }),\n  invoke: {\n    src: 'slate operation listener',\n    input: ({context}) => ({slateEditor: context.slateEditor}),\n  },\n  on: {\n    'update read only': {\n      actions: ['assign readOnly'],\n    },\n  },\n  initial: 'setting up',\n  states: {\n    'setting up': {\n      always: [\n        {\n          guard: and(['should skip setup', 'has pending range decorations']),\n          target: 'ready',\n          actions: [\n            'set up initial range decorations',\n            'increment update count',\n          ],\n        },\n        {\n          guard: 'should skip setup',\n          target: 'ready',\n        },\n      ],\n      on: {\n        'range decorations updated': {\n          actions: ['update pending range decorations'],\n        },\n        'ready': [\n          {\n            target: 'ready',\n            guard: 'has pending range decorations',\n            actions: [\n              'set up initial range decorations',\n              'increment update count',\n            ],\n          },\n          {\n            target: 'ready',\n          },\n        ],\n      },\n    },\n    'ready': {\n      initial: 'idle',\n      on: {\n        'range decorations updated': {\n          target: '.idle',\n          guard: 'has different decorations',\n          actions: ['update range decorations', 'increment update count'],\n        },\n      },\n      states: {\n        'idle': {\n          on: {\n            'slate operation': {\n              target: 'moving range decorations',\n              guard: and(['has range decorations', 'not read only']),\n            },\n          },\n        },\n        'moving range decorations': {\n          entry: ['move range decorations'],\n          always: {\n            target: 'idle',\n          },\n        },\n      },\n    },\n  },\n})\n\nexport function createDecorate(\n  rangeDecorationActor: ActorRefFrom<typeof rangeDecorationsMachine>,\n) {\n  return function decorate([node, path]: NodeEntry): Array<BaseRange> {\n    if (\n      isEqualToEmptyEditor(\n        rangeDecorationActor.getSnapshot().context.slateEditor.children,\n        rangeDecorationActor.getSnapshot().context.schema,\n      )\n    ) {\n      return [\n        {\n          anchor: {\n            path: [0, 0],\n            offset: 0,\n          },\n          focus: {\n            path: [0, 0],\n            offset: 0,\n          },\n          placeholder: true,\n        } as BaseRange,\n      ]\n    }\n\n    // Editor node has a path length of 0 (should never be decorated)\n    if (path.length === 0) {\n      return []\n    }\n\n    if (!Element.isElement(node) || node.children.length === 0) {\n      return []\n    }\n\n    const blockIndex = path.at(0)\n\n    if (blockIndex === undefined) {\n      return []\n    }\n\n    return rangeDecorationActor\n      .getSnapshot()\n      .context.decoratedRanges.filter((decoratedRange) => {\n        // Special case in order to only return one decoration for collapsed ranges\n        if (Range.isCollapsed(decoratedRange)) {\n          // Collapsed ranges should only be decorated if they are on a block child level (length 2)\n          return node.children.some(\n            (_, childIndex) =>\n              Path.equals(decoratedRange.anchor.path, [\n                blockIndex,\n                childIndex,\n              ]) &&\n              Path.equals(decoratedRange.focus.path, [blockIndex, childIndex]),\n          )\n        }\n\n        return (\n          Range.intersection(decoratedRange, {\n            anchor: {path, offset: 0},\n            focus: {path, offset: 0},\n          }) || Range.includes(decoratedRange, path)\n        )\n      })\n  }\n}\n","import {useActorRef, useSelector} from '@xstate/react'\nimport {noop} from 'lodash'\nimport {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n  type ClipboardEvent,\n  type CSSProperties,\n  type FocusEventHandler,\n  type KeyboardEvent,\n  type MutableRefObject,\n  type TextareaHTMLAttributes,\n} from 'react'\nimport {Editor, Transforms, type Text} from 'slate'\nimport {\n  ReactEditor,\n  Editable as SlateEditable,\n  useSlate,\n  type RenderElementProps,\n  type RenderLeafProps,\n} from 'slate-react'\nimport {getCompoundClientRect} from '../internal-utils/compound-client-rect'\nimport {debugWithName} from '../internal-utils/debug'\nimport {getDragSelection} from '../internal-utils/drag-selection'\nimport {getEventPosition} from '../internal-utils/event-position'\nimport {parseBlocks} from '../internal-utils/parse-blocks'\nimport {toSlateRange} from '../internal-utils/ranges'\nimport {normalizeSelection} from '../internal-utils/selection'\nimport {getSelectionDomNodes} from '../internal-utils/selection-elements'\nimport {slateRangeToSelection} from '../internal-utils/slate-utils'\nimport {fromSlateValue} from '../internal-utils/values'\nimport * as selectors from '../selectors'\nimport type {\n  EditorSelection,\n  OnCopyFn,\n  OnPasteFn,\n  RangeDecoration,\n  RenderAnnotationFunction,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n  RenderListItemFunction,\n  RenderPlaceholderFunction,\n  RenderStyleFunction,\n  ScrollSelectionIntoViewFunction,\n} from '../types/editor'\nimport type {HotkeyOptions} from '../types/options'\nimport {isSelectionCollapsed} from '../utils'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {Element} from './components/Element'\nimport {Leaf} from './components/Leaf'\nimport {EditorActorContext} from './editor-actor-context'\nimport {getEditorSnapshot} from './editor-selector'\nimport {usePortableTextEditor} from './hooks/usePortableTextEditor'\nimport {createWithHotkeys} from './plugins/createWithHotKeys'\nimport {PortableTextEditor} from './PortableTextEditor'\nimport {\n  createDecorate,\n  rangeDecorationsMachine,\n} from './range-decorations-machine'\n\nconst debug = debugWithName('component:Editable')\n\nconst PLACEHOLDER_STYLE: CSSProperties = {\n  position: 'absolute',\n  userSelect: 'none',\n  pointerEvents: 'none',\n  left: 0,\n  right: 0,\n}\n\n/**\n * @public\n */\nexport type PortableTextEditableProps = Omit<\n  TextareaHTMLAttributes<HTMLDivElement>,\n  'onPaste' | 'onCopy' | 'onBeforeInput'\n> & {\n  hotkeys?: HotkeyOptions\n  onBeforeInput?: (event: InputEvent) => void\n  onPaste?: OnPasteFn\n  onCopy?: OnCopyFn\n  ref: MutableRefObject<HTMLDivElement | null>\n  rangeDecorations?: RangeDecoration[]\n  renderAnnotation?: RenderAnnotationFunction\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  renderListItem?: RenderListItemFunction\n  renderPlaceholder?: RenderPlaceholderFunction\n  renderStyle?: RenderStyleFunction\n  scrollSelectionIntoView?: ScrollSelectionIntoViewFunction\n  selection?: EditorSelection\n  spellCheck?: boolean\n}\n\n/**\n * @public\n *\n *\n * The core component that renders the editor. Must be placed within the {@link EditorProvider} component.\n *\n * @example\n * ```tsx\n * import { PortableTextEditable, EditorProvider } from '@portabletext/editor'\n *\n * function MyComponent() {\n *  return (\n *   <EditorProvider>\n *    <PortableTextEditable />\n *  </EditorProvider>\n *  )\n * }\n * ```\n * @group Components\n */\nexport const PortableTextEditable = forwardRef<\n  Omit<HTMLDivElement, 'as' | 'onPaste' | 'onBeforeInput'>,\n  PortableTextEditableProps\n>(function PortableTextEditable(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onCut,\n    onClick,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onDragEnter,\n    onDragOver,\n    onDrop,\n    onDragLeave,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props\n\n  const portableTextEditor = usePortableTextEditor()\n  const ref = useRef<HTMLDivElement | null>(null)\n  const [editableElement, setEditableElement] = useState<HTMLDivElement | null>(\n    null,\n  )\n  const [hasInvalidValue, setHasInvalidValue] = useState(false)\n\n  // Forward ref to parent component\n  useImperativeHandle<HTMLDivElement | null, HTMLDivElement | null>(\n    forwardedRef,\n    () => ref.current,\n  )\n\n  const editorActor = useContext(EditorActorContext)\n  const readOnly = useSelector(editorActor, (s) =>\n    s.matches({'edit mode': 'read only'}),\n  )\n  const schemaTypes = useSelector(editorActor, (s) => s.context.schema)\n  const slateEditor = useSlate()\n\n  const rangeDecorationsActor = useActorRef(rangeDecorationsMachine, {\n    input: {\n      rangeDecorations: rangeDecorations ?? [],\n      readOnly,\n      schema: schemaTypes,\n      slateEditor,\n      skipSetup: !editorActor.getSnapshot().matches({setup: 'setting up'}),\n    },\n  })\n  useSelector(rangeDecorationsActor, (s) => s.context.updateCount)\n  const decorate = useMemo(\n    () => createDecorate(rangeDecorationsActor),\n    [rangeDecorationsActor],\n  )\n\n  useEffect(() => {\n    rangeDecorationsActor.send({\n      type: 'update read only',\n      readOnly,\n    })\n  }, [rangeDecorationsActor, readOnly])\n\n  useEffect(() => {\n    rangeDecorationsActor.send({\n      type: 'range decorations updated',\n      rangeDecorations: rangeDecorations ?? [],\n    })\n  }, [rangeDecorationsActor, rangeDecorations])\n\n  const blockTypeName = schemaTypes.block.name\n\n  // Output a minimal React editor inside Editable when in readOnly mode.\n  // NOTE: make sure all the plugins used here can be safely run over again at any point.\n  // There will be a problem if they redefine editor methods and then calling the original method within themselves.\n  useMemo(() => {\n    // React/UI-specific plugins\n    if (readOnly) {\n      debug('Editable is in read only mode')\n      return slateEditor\n    }\n    const withHotKeys = createWithHotkeys(\n      editorActor,\n      portableTextEditor,\n      hotkeys,\n    )\n\n    debug('Editable is in edit mode')\n    return withHotKeys(slateEditor)\n  }, [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor])\n\n  const renderElement = useCallback(\n    (eProps: RenderElementProps) => (\n      <Element\n        {...eProps}\n        readOnly={readOnly}\n        renderBlock={renderBlock}\n        renderChild={renderChild}\n        renderListItem={renderListItem}\n        renderStyle={renderStyle}\n        schemaTypes={schemaTypes}\n        spellCheck={spellCheck}\n      />\n    ),\n    [\n      schemaTypes,\n      spellCheck,\n      readOnly,\n      renderBlock,\n      renderChild,\n      renderListItem,\n      renderStyle,\n    ],\n  )\n\n  const renderLeaf = useCallback(\n    (\n      lProps: RenderLeafProps & {\n        leaf: Text & {placeholder?: boolean; rangeDecoration?: RangeDecoration}\n      },\n    ) => {\n      if (lProps.leaf._type === 'span') {\n        let rendered = (\n          <Leaf\n            {...lProps}\n            editorActor={editorActor}\n            schemaTypes={schemaTypes}\n            renderAnnotation={renderAnnotation}\n            renderChild={renderChild}\n            renderDecorator={renderDecorator}\n            readOnly={readOnly}\n          />\n        )\n        if (\n          renderPlaceholder &&\n          lProps.leaf.placeholder &&\n          lProps.text.text === ''\n        ) {\n          return (\n            <>\n              <span style={PLACEHOLDER_STYLE} contentEditable={false}>\n                {renderPlaceholder()}\n              </span>\n              {rendered}\n            </>\n          )\n        }\n        const decoration = lProps.leaf.rangeDecoration\n        if (decoration) {\n          rendered = decoration.component({children: rendered})\n        }\n        return rendered\n      }\n      return lProps.children\n    },\n    [\n      editorActor,\n      readOnly,\n      renderAnnotation,\n      renderChild,\n      renderDecorator,\n      renderPlaceholder,\n      schemaTypes,\n    ],\n  )\n\n  const restoreSelectionFromProps = useCallback(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`)\n      const normalizedSelection = normalizeSelection(\n        propsSelection,\n        fromSlateValue(slateEditor.children, blockTypeName),\n      )\n      if (normalizedSelection !== null) {\n        debug(\n          `Normalized selection from props ${JSON.stringify(normalizedSelection)}`,\n        )\n        const slateRange = toSlateRange(normalizedSelection, slateEditor)\n        if (slateRange) {\n          Transforms.select(slateEditor, slateRange)\n          // Output selection here in those cases where the editor selection was the same, and there are no set_selection operations made.\n          // The selection is usually automatically emitted to change$ by the withPortableTextSelections plugin whenever there is a set_selection operation applied.\n          if (!slateEditor.operations.some((o) => o.type === 'set_selection')) {\n            editorActor.send({\n              type: 'notify.selection',\n              selection: normalizedSelection,\n            })\n          }\n          slateEditor.onChange()\n        }\n      }\n    }\n  }, [blockTypeName, editorActor, propsSelection, slateEditor])\n\n  // Restore selection from props when the editor has been initialized properly with it's value\n  useEffect(() => {\n    const onReady = editorActor.on('ready', () => {\n      rangeDecorationsActor.send({\n        type: 'ready',\n      })\n\n      restoreSelectionFromProps()\n    })\n\n    const onInvalidValue = editorActor.on('invalid value', () => {\n      setHasInvalidValue(true)\n    })\n\n    const onValueChanged = editorActor.on('value changed', () => {\n      setHasInvalidValue(false)\n    })\n\n    return () => {\n      onReady.unsubscribe()\n      onInvalidValue.unsubscribe()\n      onValueChanged.unsubscribe()\n    }\n  }, [rangeDecorationsActor, editorActor, restoreSelectionFromProps])\n\n  // Restore selection from props when it changes\n  useEffect(() => {\n    if (propsSelection && !hasInvalidValue) {\n      restoreSelectionFromProps()\n    }\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps])\n\n  // Handle from props onCopy function\n  const handleCopy = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): void | ReactEditor => {\n      if (onCopy) {\n        const result = onCopy(event)\n        // CopyFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const selection = slateEditor.selection\n          ? slateRangeToSelection({\n              schema: editorActor.getSnapshot().context.schema,\n              editor: slateEditor,\n              range: slateEditor.selection,\n            })\n          : undefined\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for copy event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.copy',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCopy, editorActor, slateEditor],\n  )\n\n  const handleCut = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>) => {\n      if (onCut) {\n        const result = onCut(event)\n        // CutFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const selection = editorActor.getSnapshot().context.selection\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for cut event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.cut',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCut, editorActor, slateEditor],\n  )\n\n  // Handle incoming pasting events in the editor\n  const handlePaste = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): Promise<void> | void => {\n      const value = PortableTextEditor.getValue(portableTextEditor)\n      const ptRange = slateEditor.selection\n        ? slateRangeToSelection({\n            schema: schemaTypes,\n            editor: slateEditor,\n            range: slateEditor.selection,\n          })\n        : null\n      const path = ptRange?.focus.path || []\n      const onPasteResult = onPaste?.({event, value, path, schemaTypes})\n\n      if (onPasteResult || !slateEditor.selection) {\n        event.preventDefault()\n\n        // Resolve it as promise (can be either async promise or sync return value)\n        editorActor.send({type: 'notify.loading'})\n\n        Promise.resolve(onPasteResult)\n          .then((result) => {\n            debug('Custom paste function from client resolved', result)\n\n            if (!result || !result.insert) {\n              debug('No result from custom paste handler, pasting normally')\n\n              const selection = editorActor.getSnapshot().context.selection\n              const position = selection ? {selection} : undefined\n\n              if (!position) {\n                console.warn('Could not find position for paste event')\n                return\n              }\n\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'clipboard.paste',\n                  originEvent: {\n                    dataTransfer: event.clipboardData,\n                  },\n                  position,\n                },\n                editor: slateEditor,\n                nativeEvent: event,\n              })\n            } else if (result.insert) {\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'insert.blocks',\n                  blocks: parseBlocks({\n                    context: {\n                      keyGenerator:\n                        editorActor.getSnapshot().context.keyGenerator,\n                      schema: editorActor.getSnapshot().context.schema,\n                    },\n                    blocks: result.insert,\n                    options: {\n                      refreshKeys: true,\n                    },\n                  }),\n                  placement: 'auto',\n                },\n                editor: slateEditor,\n              })\n            } else {\n              console.warn(\n                'Your onPaste function returned something unexpected:',\n                result,\n              )\n            }\n          })\n          .catch((error) => {\n            console.warn(error)\n\n            return error\n          })\n          .finally(() => {\n            editorActor.send({type: 'notify.done loading'})\n          })\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.preventDefault()\n        event.stopPropagation()\n\n        const selection = editorActor.getSnapshot().context.selection\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for paste event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.paste',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n\n      debug('No result from custom paste handler, pasting normally')\n    },\n    [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor],\n  )\n\n  const handleOnFocus: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onFocus) {\n        onFocus(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        const selection = PortableTextEditor.getSelection(portableTextEditor)\n        // Create an editor selection if it does'nt exist\n        if (selection === null) {\n          Transforms.select(slateEditor, Editor.start(slateEditor, []))\n          slateEditor.onChange()\n        }\n        editorActor.send({type: 'notify.focused', event})\n        const newSelection = PortableTextEditor.getSelection(portableTextEditor)\n        // If the selection is the same, emit it explicitly here as there is no actual onChange event triggered.\n        if (selection === newSelection) {\n          editorActor.send({\n            type: 'notify.selection',\n            selection,\n          })\n        }\n      }\n    },\n    [editorActor, onFocus, portableTextEditor, slateEditor],\n  )\n\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n      if (onClick) {\n        onClick(event)\n      }\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (position) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'mouse.click',\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onClick, editorActor, slateEditor],\n  )\n\n  const handleOnBlur: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onBlur) {\n        onBlur(event)\n      }\n      if (!event.isPropagationStopped()) {\n        editorActor.send({type: 'notify.blurred', event})\n      }\n    },\n    [editorActor, onBlur],\n  )\n\n  const handleOnBeforeInput = useCallback(\n    (event: InputEvent) => {\n      if (onBeforeInput) {\n        onBeforeInput(event)\n      }\n    },\n    [onBeforeInput],\n  )\n\n  // This function will handle unexpected DOM changes inside the Editable rendering,\n  // and make sure that we can maintain a stable slateEditor.selection when that happens.\n  //\n  // For example, if this Editable is rendered inside something that might re-render\n  // this component (hidden contexts) while the user is still actively changing the\n  // contentEditable, this could interfere with the intermediate DOM selection,\n  // which again could be picked up by ReactEditor's event listeners.\n  // If that range is invalid at that point, the slate.editorSelection could be\n  // set either wrong, or invalid, to which slateEditor will throw exceptions\n  // that are impossible to recover properly from or result in a wrong selection.\n  //\n  // Also the other way around, when the ReactEditor will try to create a DOM Range\n  // from the current slateEditor.selection, it may throw unrecoverable errors\n  // if the current editor.selection is invalid according to the DOM.\n  // If this is the case, default to selecting the top of the document, if the\n  // user already had a selection.\n  const validateSelection = useCallback(() => {\n    if (!slateEditor.selection) {\n      return\n    }\n    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor)\n    const {activeElement} = root\n    // Return if the editor isn't the active element\n    if (ref.current !== activeElement) {\n      return\n    }\n    const window = ReactEditor.getWindow(slateEditor)\n    const domSelection = window.getSelection()\n    if (!domSelection || domSelection.rangeCount === 0) {\n      return\n    }\n    const existingDOMRange = domSelection.getRangeAt(0)\n    try {\n      const newDOMRange = ReactEditor.toDOMRange(\n        slateEditor,\n        slateEditor.selection,\n      )\n      if (\n        newDOMRange.startOffset !== existingDOMRange.startOffset ||\n        newDOMRange.endOffset !== existingDOMRange.endOffset\n      ) {\n        debug('DOM range out of sync, validating selection')\n        // Remove all ranges temporary\n        domSelection?.removeAllRanges()\n        // Set the correct range\n        domSelection.addRange(newDOMRange)\n      }\n    } catch {\n      debug(`Could not resolve selection, selecting top document`)\n      // Deselect the editor\n      Transforms.deselect(slateEditor)\n      // Select top document if there is a top block to select\n      if (slateEditor.children.length > 0) {\n        Transforms.select(slateEditor, [0, 0])\n      }\n      slateEditor.onChange()\n    }\n  }, [ref, slateEditor])\n\n  // Observe mutations (child list and subtree) to this component's DOM,\n  // and make sure the editor selection is valid when that happens.\n  useEffect(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection)\n      mutationObserver.observe(editableElement, {\n        attributeOldValue: false,\n        attributes: false,\n        characterData: false,\n        childList: true,\n        subtree: true,\n      })\n      return () => {\n        mutationObserver.disconnect()\n      }\n    }\n    return undefined\n  }, [validateSelection, editableElement])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyDown) {\n        props.onKeyDown(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        slateEditor.pteWithHotKeys(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keydown',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const handleKeyUp = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyUp) {\n        props.onKeyUp(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keyup',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const scrollSelectionIntoViewToSlate = useMemo(() => {\n    // Use slate-react default scroll into view\n    if (scrollSelectionIntoView === undefined) {\n      return undefined\n    }\n    // Disable scroll into view totally\n    if (scrollSelectionIntoView === null) {\n      return noop\n    }\n    // Translate PortableTextEditor prop fn to Slate plugin fn\n    return (_editor: ReactEditor, domRange: Range) => {\n      scrollSelectionIntoView(portableTextEditor, domRange)\n    }\n  }, [portableTextEditor, scrollSelectionIntoView])\n\n  // Set the forwarded ref to be the Slate editable DOM element\n  // Also set the editable element in a state so that the MutationObserver\n  // is setup when this element is ready.\n  useEffect(() => {\n    ref.current = ReactEditor.toDOMNode(\n      slateEditor,\n      slateEditor,\n    ) as HTMLDivElement | null\n    setEditableElement(ref.current)\n  }, [slateEditor, ref])\n\n  useEffect(() => {\n    const window = ReactEditor.getWindow(slateEditor)\n\n    const onDragEnd = () => {\n      editorActor.send({type: 'dragend'})\n    }\n    const onDrop = () => {\n      editorActor.send({type: 'drop'})\n    }\n\n    window.document.addEventListener('dragend', onDragEnd)\n    window.document.addEventListener('drop', onDrop)\n\n    return () => {\n      window.document.removeEventListener('dragend', onDragEnd)\n      window.document.removeEventListener('drop', onDrop)\n    }\n  }, [slateEditor, editorActor])\n\n  const handleDragStart = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragStart?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find position for dragstart event')\n        return\n      }\n\n      const snapshot = getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: slateEditor,\n      })\n      const dragSelection = getDragSelection({\n        eventSelection: position.selection,\n        snapshot,\n      })\n\n      const selectingEntireBlocks = selectors.isSelectingEntireBlocks({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragSelection,\n        },\n      })\n\n      const dragGhost = document.createElement('div')\n\n      const draggedDomNodes = getSelectionDomNodes({\n        snapshot: {\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragSelection,\n          },\n        },\n        slateEditor,\n      })\n\n      if (selectingEntireBlocks) {\n        // Clone the DOM Nodes so they won't be visually clipped by scroll-containers etc.\n        const clonedBlockNodes = draggedDomNodes.blockNodes.map((node) =>\n          node.cloneNode(true),\n        )\n\n        for (const block of clonedBlockNodes) {\n          if (block instanceof HTMLElement) {\n            block.style.position = 'relative'\n          }\n          dragGhost.appendChild(block)\n        }\n\n        // A custom drag ghost element can be configured using this data attribute\n        const customGhost = dragGhost.querySelector(\n          '[data-pt-drag-ghost-element]',\n        )\n        if (customGhost) {\n          dragGhost.replaceChildren(customGhost)\n        }\n\n        // Setting the `data-dragged` attribute so the consumer can style the element while its dragged\n        dragGhost.setAttribute('data-dragged', '')\n\n        dragGhost.style.position = 'absolute'\n        dragGhost.style.left = '-99999px'\n        dragGhost.style.boxSizing = 'border-box'\n        document.body.appendChild(dragGhost)\n\n        if (customGhost) {\n          const customGhostRect = customGhost.getBoundingClientRect()\n          const x = event.clientX - customGhostRect.left\n          const y = event.clientY - customGhostRect.top\n          dragGhost.style.width = `${customGhostRect.width}px`\n          dragGhost.style.height = `${customGhostRect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n        } else {\n          const blocksDomRect = getCompoundClientRect(\n            draggedDomNodes.blockNodes,\n          )\n          const x = event.clientX - blocksDomRect.left\n          const y = event.clientY - blocksDomRect.top\n          dragGhost.style.width = `${blocksDomRect.width}px`\n          dragGhost.style.height = `${blocksDomRect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n        }\n      } else {\n        const clonedChildNodes = draggedDomNodes.childNodes.map((node) =>\n          node.cloneNode(true),\n        )\n\n        for (const child of clonedChildNodes) {\n          dragGhost.appendChild(child)\n        }\n\n        dragGhost.style.position = 'absolute'\n        dragGhost.style.left = '-99999px'\n        dragGhost.style.boxSizing = 'border-box'\n        document.body.appendChild(dragGhost)\n\n        const childrenDomRect = getCompoundClientRect(\n          draggedDomNodes.childNodes,\n        )\n        const x = event.clientX - childrenDomRect.left\n        const y = event.clientY - childrenDomRect.top\n        dragGhost.style.width = `${childrenDomRect.width}px`\n        dragGhost.style.height = `${childrenDomRect.height}px`\n\n        event.dataTransfer.setDragImage(dragGhost, x, y)\n      }\n\n      // Select drag selection\n      // If the selection is expanded then we just select the end of the\n      // selection\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'select',\n          selection: isSelectionCollapsed(dragSelection)\n            ? dragSelection\n            : {\n                anchor: getSelectionEndPoint(dragSelection),\n                focus: getSelectionEndPoint(dragSelection),\n                backward: false,\n              },\n        },\n        editor: slateEditor,\n      })\n\n      editorActor.send({\n        type: 'dragstart',\n        origin: {\n          selection: dragSelection,\n        },\n        ghost: dragGhost,\n      })\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragstart',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position: {\n            selection: dragSelection,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragStart, editorActor, slateEditor],\n  )\n\n  const handleDrag = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrag?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.drag',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDrag, editorActor, slateEditor],\n  )\n\n  const handleDragEnd = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnd?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragend',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragEnd, editorActor, slateEditor],\n  )\n\n  const handleDragEnter = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnter?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragenter',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragEnter, editorActor, slateEditor],\n  )\n\n  const handleDragOver = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragOver?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragover',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragOver, editorActor, slateEditor],\n  )\n\n  const handleDrop = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrop?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find position for drop event')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.drop',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDrop, editorActor, slateEditor],\n  )\n\n  const handleDragLeave = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragLeave?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        editorActor,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragleave',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragLeave, editorActor, slateEditor],\n  )\n\n  if (!portableTextEditor) {\n    return null\n  }\n\n  return hasInvalidValue ? null : (\n    <SlateEditable\n      {...restProps}\n      autoFocus={false}\n      className={restProps.className || 'pt-editable'}\n      decorate={decorate}\n      onBlur={handleOnBlur}\n      onCopy={handleCopy}\n      onCut={handleCut}\n      onClick={handleClick}\n      onDOMBeforeInput={handleOnBeforeInput}\n      onDragStart={handleDragStart}\n      onDrag={handleDrag}\n      onDragEnd={handleDragEnd}\n      onDragEnter={handleDragEnter}\n      onDragOver={handleDragOver}\n      onDrop={handleDrop}\n      onDragLeave={handleDragLeave}\n      onFocus={handleOnFocus}\n      onKeyDown={handleKeyDown}\n      onKeyUp={handleKeyUp}\n      onPaste={handlePaste}\n      readOnly={readOnly}\n      // We have implemented our own placeholder logic with decorations.\n      // This 'renderPlaceholder' should not be used.\n      renderPlaceholder={undefined}\n      renderElement={renderElement}\n      renderLeaf={renderLeaf}\n      scrollSelectionIntoView={scrollSelectionIntoViewToSlate}\n    />\n  )\n})\n\nPortableTextEditable.displayName = 'ForwardRef(PortableTextEditable)'\n"],"names":["EditorEventListener","props","$","_c","editor","useEditor","on","useEffectEvent","t0","subscription","unsubscribe","t1","useEffect","getCompoundClientRect","nodes","length","DOMRect","elements","filter","node","Element","firstRect","at","getBoundingClientRect","left","top","right","bottom","i","rect","Math","min","max","getDragSelection","eventSelection","snapshot","dragSelection","selectors","context","selection","draggingCollapsedSelection","draggedTextBlock","draggedSpan","anchor","utils","focus","selectedBlocks","selectionStartBlock","selectionEndBlock","selectionStartPoint","selectionEndPoint","getEventPosition","editorActor","slateEditor","event","getSnapshot","matches","setup","getEventNode","block","getNodeBlock","schema","positionBlock","getEventPositionBlock","getEventSelection","Editor","isEditor","path","_key","focusBlockPath","focusBlockKey","undefined","DOMEditor","hasTarget","target","toSlateNode","firstBlock","getFirstBlock","firstBlockRect","toDOMNode","pageY","lastBlock","getLastBlock","lastBlockRef","elementRect","height","abs","range","getSlateRangeFromEvent","slateRangeToSelection","isDOMNode","window","getWindow","domRange","document","caretPositionFromPoint","position","clientX","clientY","createRange","setStart","offsetNode","offset","setEnd","caretRangeFromPoint","console","warn","toSlateRange","exactMatch","suppressThrow","normalizePoint","point","value","newPath","newOffset","blockKey","childKey","find","blk","push","children","Array","isArray","child","cld","text","normalizeSelection","newAnchor","newFocus","isEqual","backward","getSelectionDomNodes","blockNodes","childNodes","blockEntries","from","mode","match","n","childEntries","isTextSpan","isBlock","map","blockNode","childNode","DefaultBlockObject","Symbol","for","userSelect","_type","DefaultInlineObject","DropIndicator","width","borderBottom","zIndex","debugWithName","EMPTY_ANNOTATIONS","inlineBlockStyle","display","attributes","element","schemaTypes","readOnly","renderBlock","renderChild","renderListItem","renderStyle","spellCheck","useContext","EditorActorContext","useSlateStatic","selected","useSelected","blockRef","useRef","inlineBlockObjectRef","focused","Range","isCollapsed","dragPositionBlock","setDragPositionBlock","useState","behavior","defineBehavior","guard","dropFocusBlock","dragOrigin","beta","internalDrag","origin","some","draggedBlock","actions","type","effect","send","useMemo","fromSlateValue","name","KEY_TO_VALUE_ELEMENT","get","renderedBlock","className","blockPath","Error","isInline","ReactEditor","findPath","depth","schemaType","inlineObjects","SlateElement","isElement","elmPath","debugRenders","annotations","editorElementRef","isListItem","style","blockStyleType","styles","item","level","listItem","isListBlock","listType","lists","renderProps","Object","defineProperty","enumerable","propsOrDefaultRendered","blockObjects","renderedBlockFromProps","_props","displayName","debug","EMPTY_MARKS","Leaf","leaf","renderDecorator","renderAnnotation","spanRef","portableTextEditor","usePortableTextEditor","blockSelected","setFocused","setSelected","parent","decoratorValues","decorators","dec","marks","uniq","mark","includes","annotationMarks","markDefs","def","Boolean","shouldTrackSelectionAndFocus","sel","PortableTextEditor","getSelection","isCollapsedSelection","startTransition","setSelectedFromRange","useCallback","winSelection","rangeCount","getRangeAt","current","intersectsNode","onBlur","onFocus","onSelection","content","returnedChildren","Text","isText","span","forEach","annotation","t","_child","createWithHotkeys","hotkeysFromOptions","reservedHotkeys","activeHotkeys","pteWithHotKeys","keys","cat","hotkey","isHotkey","nativeEvent","preventDefault","possibleMark","behaviorEvent","decorator","possibleCommand","command","slateOperationCallback","input","sendBack","originalApply","apply","op","operation","rangeDecorationsMachine","types","events","assign","pendingRangeDecorations","assertEvent","rangeDecorations","decoratedRanges","rangeDecorationState","rangeDecoration","slateRange","isRange","onMoved","newSelection","decoratedRange","newRange","moveRangeByOperation","newRangeSelection","updateCount","actors","fromCallback","guards","has pending range decorations","has range decorations","has different decorations","existingRangeDecorations","newRangeDecorations","not read only","should skip setup","skipSetup","createMachine","id","invoke","src","initial","states","always","and","entry","createDecorate","rangeDecorationActor","isEqualToEmptyEditor","placeholder","blockIndex","_","childIndex","Path","equals","intersection","PLACEHOLDER_STYLE","pointerEvents","PortableTextEditable","forwardRef","forwardedRef","hotkeys","onBeforeInput","onPaste","onCopy","onCut","onClick","onDragStart","onDrag","onDragEnd","onDragEnter","onDragOver","onDrop","onDragLeave","renderPlaceholder","propsSelection","scrollSelectionIntoView","restProps","ref","editableElement","setEditableElement","hasInvalidValue","setHasInvalidValue","useSelector","s","useSlate","rangeDecorationsActor","useActorRef","decorate","blockTypeName","withHotKeys","renderElement","eProps","renderLeaf","lProps","rendered","decoration","component","restoreSelectionFromProps","JSON","stringify","normalizedSelection","Transforms","select","operations","o","onChange","onReady","onInvalidValue","onValueChanged","handleCopy","clipboardData","stopPropagation","originEvent","dataTransfer","handleCut","handlePaste","getValue","onPasteResult","Promise","resolve","then","result","insert","blocks","parseBlocks","keyGenerator","options","refreshKeys","placement","catch","error","finally","handleOnFocus","isDefaultPrevented","start","handleClick","isPropagationStopped","handleOnBlur","handleOnBeforeInput","validateSelection","root","findDocumentOrShadowRoot","activeElement","domSelection","existingDOMRange","newDOMRange","toDOMRange","startOffset","endOffset","removeAllRanges","addRange","deselect","mutationObserver","MutationObserver","observe","attributeOldValue","characterData","childList","subtree","disconnect","handleKeyDown","onKeyDown","key","code","altKey","ctrlKey","metaKey","shiftKey","handleKeyUp","onKeyUp","scrollSelectionIntoViewToSlate","noop","_editor","addEventListener","removeEventListener","handleDragStart","getEditorSnapshot","editorActorSnapshot","slateEditorInstance","selectingEntireBlocks","dragGhost","createElement","draggedDomNodes","clonedBlockNodes","cloneNode","HTMLElement","appendChild","customGhost","querySelector","replaceChildren","setAttribute","boxSizing","body","customGhostRect","x","y","setDragImage","blocksDomRect","clonedChildNodes","childrenDomRect","isSelectionCollapsed","getSelectionEndPoint","ghost","handleDrag","handleDragEnd","handleDragEnter","handleDragOver","handleDrop","handleDragLeave","SlateEditable"],"mappings":"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"}