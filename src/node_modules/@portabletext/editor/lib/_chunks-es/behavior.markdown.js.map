{"version":3,"file":"behavior.markdown.js","sources":["../../src/behaviors/behavior.markdown.ts"],"sourcesContent":["import {isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\nimport * as selectors from '../selectors'\nimport {spanSelectionPointToBlockOffset} from '../utils/util.block-offset'\nimport {getTextBlockText} from '../utils/util.get-text-block-text'\nimport {defineBehavior} from './behavior.types.behavior'\n\n/**\n * @beta\n */\nexport type MarkdownBehaviorsConfig = {\n  horizontalRuleObject?: (context: {\n    schema: EditorSchema\n  }) => {name: string; value?: {[prop: string]: unknown}} | undefined\n  defaultStyle?: (context: {schema: EditorSchema}) => string | undefined\n  headingStyle?: (context: {\n    schema: EditorSchema\n    level: number\n  }) => string | undefined\n  blockquoteStyle?: (context: {schema: EditorSchema}) => string | undefined\n  unorderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n  orderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n}\n\n/**\n * @beta\n * Create markdown behaviors for common markdown actions such as converting ### to headings, --- to HRs, and more.\n *\n * @example\n * Configure the bundled markdown behaviors\n * ```ts\n * import {EditorProvider} from '@portabletext/editor'\n * import {createMarkdownBehaviors, coreBehaviors} from '@portabletext/editor/behaviors'\n *\n * function App() {\n *  return (\n *   <EditorProvider\n *    initialConfig={{\n *    behaviors: [\n *    ...coreBehaviors,\n *    ...createMarkdownBehaviors({\n *        horizontalRuleObject: ({schema}) => {\n *          const name = schema.blockObjects.find(\n *            (object) => object.name === 'break',\n *          )?.name\n *          return name ? {name} : undefined\n *        },\n *        defaultStyle: ({schema}) => schema.styles[0].value,\n *        headingStyle: ({schema, level}) =>\n *          schema.styles.find((style) => style.value === `h${level}`)\n *            ?.value,\n *        blockquoteStyle: ({schema}) =>\n *          schema.styles.find((style) => style.value === 'blockquote')\n *            ?.value,\n *        unorderedListStyle: ({schema}) =>\n *          schema.lists.find((list) => list.value === 'bullet')?.value,\n *        orderedListStyle: ({schema}) =>\n *          schema.lists.find((list) => list.value === 'number')?.value,\n *      }),\n *      ]\n *    }}\n *    >\n *    {...}\n *    </EditorProvider>\n *  )\n * }\n * ```\n *\n */\nexport function createMarkdownBehaviors(config: MarkdownBehaviorsConfig) {\n  const automaticBlockquoteOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const focusSpan = selectors.getFocusSpan(snapshot)\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject(snapshot)\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: snapshot.context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: snapshot.context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (previousInlineObject || !blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const caretAtTheEndOfQuote = blockOffset.offset === 1\n      const looksLikeMarkdownQuote = /^>/.test(blockText)\n      const blockquoteStyle = config.blockquoteStyle?.(snapshot.context)\n\n      if (\n        caretAtTheEndOfQuote &&\n        looksLikeMarkdownQuote &&\n        blockquoteStyle !== undefined\n      ) {\n        return {focusTextBlock, style: blockquoteStyle}\n      }\n\n      return false\n    },\n    actions: [\n      () => [\n        {\n          type: 'insert.text',\n          text: ' ',\n        },\n      ],\n      (_, {focusTextBlock, style}) => [\n        {\n          type: 'block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'block.set',\n          props: {style},\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: 2,\n          },\n        },\n      ],\n    ],\n  })\n  const automaticHr = defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event}) => {\n      const hrCharacter =\n        event.text === '-'\n          ? '-'\n          : event.text === '*'\n            ? '*'\n            : event.text === '_'\n              ? '_'\n              : undefined\n\n      if (hrCharacter === undefined) {\n        return false\n      }\n\n      const hrObject = config.horizontalRuleObject?.(snapshot.context)\n      const focusBlock = selectors.getFocusTextBlock(snapshot)\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n\n      if (!hrObject || !focusBlock || !selectionCollapsed) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject(snapshot)\n      const textBefore = selectors.getBlockTextBefore(snapshot)\n      const hrBlockOffsets = {\n        anchor: {\n          path: focusBlock.path,\n          offset: 0,\n        },\n        focus: {\n          path: focusBlock.path,\n          offset: 3,\n        },\n      }\n\n      if (\n        !previousInlineObject &&\n        textBefore === `${hrCharacter}${hrCharacter}`\n      ) {\n        return {hrObject, focusBlock, hrCharacter, hrBlockOffsets}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {hrCharacter}) => [\n        {\n          type: 'insert.text',\n          text: hrCharacter,\n        },\n      ],\n      (_, {hrObject, hrBlockOffsets}) => [\n        {\n          type: 'insert.block',\n          placement: 'before',\n          block: {\n            _type: hrObject.name,\n            ...(hrObject.value ?? {}),\n          },\n        },\n        {\n          type: 'delete.text',\n          ...hrBlockOffsets,\n        },\n      ],\n    ],\n  })\n  const automaticHrOnPaste = defineBehavior({\n    on: 'clipboard.paste',\n    guard: ({snapshot, event}) => {\n      const text = event.originEvent.dataTransfer.getData('text/plain')\n      const hrRegExp = /^(---)$|(___)$|(\\*\\*\\*)$/gm\n      const hrCharacters = text.match(hrRegExp)?.[0]\n      const hrObject = config.horizontalRuleObject?.(snapshot.context)\n      const focusBlock = selectors.getFocusBlock(snapshot)\n\n      if (!hrCharacters || !hrObject || !focusBlock) {\n        return false\n      }\n\n      return {hrCharacters, hrObject, focusBlock}\n    },\n    actions: [\n      (_, {hrCharacters}) => [\n        {\n          type: 'insert.text',\n          text: hrCharacters,\n        },\n      ],\n      ({snapshot}, {hrObject, focusBlock}) =>\n        isPortableTextTextBlock(focusBlock.node)\n          ? [\n              {\n                type: 'insert.block',\n                block: {\n                  _type: snapshot.context.schema.block.name,\n                  children: focusBlock.node.children,\n                },\n                placement: 'after',\n              },\n              {\n                type: 'insert.block',\n                block: {\n                  _type: hrObject.name,\n                  ...(hrObject.value ?? {}),\n                },\n                placement: 'after',\n              },\n              {type: 'delete.block', at: focusBlock.path},\n            ]\n          : [\n              {\n                type: 'insert.block',\n                block: {\n                  _type: hrObject.name,\n                  ...(hrObject.value ?? {}),\n                },\n                placement: 'after',\n              },\n            ],\n    ],\n  })\n  const automaticHeadingOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const focusSpan = selectors.getFocusSpan(snapshot)\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: snapshot.context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: snapshot.context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject(snapshot)\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const markdownHeadingSearch = /^#+/.exec(blockText)\n      const level = markdownHeadingSearch\n        ? markdownHeadingSearch[0].length\n        : undefined\n      const caretAtTheEndOfHeading = blockOffset.offset === level\n\n      if (previousInlineObject || !caretAtTheEndOfHeading) {\n        return false\n      }\n\n      const style =\n        level !== undefined\n          ? config.headingStyle?.({schema: snapshot.context.schema, level})\n          : undefined\n\n      if (level !== undefined && style !== undefined) {\n        return {\n          focusTextBlock,\n          style: style,\n          level,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [event],\n      (_, {focusTextBlock, style, level}) => [\n        {\n          type: 'block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'block.set',\n          props: {style},\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: level + 1,\n          },\n        },\n      ],\n    ],\n  })\n  const clearStyleOnBackspace = defineBehavior({\n    on: 'delete.backward',\n    guard: ({snapshot}) => {\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const focusSpan = selectors.getFocusSpan(snapshot)\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const atTheBeginningOfBLock =\n        focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n        snapshot.context.selection?.focus.offset === 0\n\n      const defaultStyle = config.defaultStyle?.(snapshot.context)\n\n      if (\n        atTheBeginningOfBLock &&\n        defaultStyle &&\n        focusTextBlock.node.style !== defaultStyle\n      ) {\n        return {defaultStyle, focusTextBlock}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {defaultStyle, focusTextBlock}) => [\n        {\n          type: 'block.set',\n          props: {style: defaultStyle},\n          at: focusTextBlock.path,\n        },\n      ],\n    ],\n  })\n  const automaticListOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({snapshot, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed(snapshot)\n      const focusTextBlock = selectors.getFocusTextBlock(snapshot)\n      const focusSpan = selectors.getFocusSpan(snapshot)\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject(snapshot)\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: snapshot.context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: snapshot.context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (previousInlineObject || !blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const defaultStyle = config.defaultStyle?.(snapshot.context)\n      const looksLikeUnorderedList = /^(-|\\*)/.test(blockText)\n      const unorderedListStyle = config.unorderedListStyle?.(snapshot.context)\n      const caretAtTheEndOfUnorderedList = blockOffset.offset === 1\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfUnorderedList &&\n        looksLikeUnorderedList &&\n        unorderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: unorderedListStyle,\n          listItemLength: 1,\n          style: defaultStyle,\n        }\n      }\n\n      const looksLikeOrderedList = /^1\\./.test(blockText)\n      const orderedListStyle = config.orderedListStyle?.(snapshot.context)\n      const caretAtTheEndOfOrderedList = blockOffset.offset === 2\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfOrderedList &&\n        looksLikeOrderedList &&\n        orderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: orderedListStyle,\n          listItemLength: 2,\n          style: defaultStyle,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [event],\n      (_, {focusTextBlock, style, listItem, listItemLength}) => [\n        {\n          type: 'block.set',\n          props: {\n            listItem,\n            level: 1,\n            style,\n          },\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: listItemLength + 1,\n          },\n        },\n      ],\n    ],\n  })\n\n  const markdownBehaviors = [\n    automaticBlockquoteOnSpace,\n    automaticHeadingOnSpace,\n    automaticHr,\n    automaticHrOnPaste,\n    clearStyleOnBackspace,\n    automaticListOnSpace,\n  ]\n\n  return markdownBehaviors\n}\n"],"names":["createMarkdownBehaviors","config","automaticBlockquoteOnSpace","defineBehavior","on","guard","snapshot","event","text","selectionCollapsed","selectors","focusTextBlock","focusSpan","previousInlineObject","blockOffset","spanSelectionPointToBlockOffset","value","context","selectionPoint","path","_key","node","offset","selection","focus","blockText","getTextBlockText","caretAtTheEndOfQuote","looksLikeMarkdownQuote","test","blockquoteStyle","undefined","style","actions","type","_","props","at","anchor","automaticHr","hrCharacter","hrObject","horizontalRuleObject","focusBlock","textBefore","hrBlockOffsets","placement","block","_type","name","automaticHrOnPaste","originEvent","dataTransfer","getData","hrRegExp","hrCharacters","match","isPortableTextTextBlock","schema","children","automaticHeadingOnSpace","markdownHeadingSearch","exec","level","length","caretAtTheEndOfHeading","headingStyle","clearStyleOnBackspace","atTheBeginningOfBLock","defaultStyle","automaticListOnSpace","looksLikeUnorderedList","unorderedListStyle","caretAtTheEndOfUnorderedList","listItem","listItemLength","looksLikeOrderedList","orderedListStyle","caretAtTheEndOfOrderedList"],"mappings":"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"}