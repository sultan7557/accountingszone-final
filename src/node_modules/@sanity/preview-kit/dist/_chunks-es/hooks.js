import { createContext, useState, useEffect, useSyncExternalStore, useContext, useMemo, useCallback } from "react";
import { useSyncExternalStoreWithSelector } from "use-sync-external-store/with-selector";
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
var reactFastCompare, hasRequiredReactFastCompare;
function requireReactFastCompare() {
  if (hasRequiredReactFastCompare) return reactFastCompare;
  hasRequiredReactFastCompare = 1;
  var hasElementType = typeof Element < "u", hasMap = typeof Map == "function", hasSet = typeof Set == "function", hasArrayBuffer = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
  function equal(a, b) {
    if (a === b) return !0;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) return !1;
      var length, i, keys;
      if (Array.isArray(a)) {
        if (length = a.length, length != b.length) return !1;
        for (i = length; i-- !== 0; )
          if (!equal(a[i], b[i])) return !1;
        return !0;
      }
      var it;
      if (hasMap && a instanceof Map && b instanceof Map) {
        if (a.size !== b.size) return !1;
        for (it = a.entries(); !(i = it.next()).done; )
          if (!b.has(i.value[0])) return !1;
        for (it = a.entries(); !(i = it.next()).done; )
          if (!equal(i.value[1], b.get(i.value[0]))) return !1;
        return !0;
      }
      if (hasSet && a instanceof Set && b instanceof Set) {
        if (a.size !== b.size) return !1;
        for (it = a.entries(); !(i = it.next()).done; )
          if (!b.has(i.value[0])) return !1;
        return !0;
      }
      if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        if (length = a.length, length != b.length) return !1;
        for (i = length; i-- !== 0; )
          if (a[i] !== b[i]) return !1;
        return !0;
      }
      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf == "function" && typeof b.valueOf == "function") return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString && typeof a.toString == "function" && typeof b.toString == "function") return a.toString() === b.toString();
      if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;
      if (hasElementType && a instanceof Element) return !1;
      for (i = length; i-- !== 0; )
        if (!((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) && !equal(a[keys[i]], b[keys[i]]))
          return !1;
      return !0;
    }
    return a !== a && b !== b;
  }
  return reactFastCompare = function(a, b) {
    try {
      return equal(a, b);
    } catch (error) {
      if ((error.message || "").match(/stack|recursion/i))
        return console.warn("react-fast-compare cannot handle circular refs"), !1;
      throw error;
    }
  }, reactFastCompare;
}
var reactFastCompareExports = requireReactFastCompare(), isEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompareExports);
const defineStoreContext = createContext(null);
function useLiveQuery(initialData, query, queryParams, options) {
  const { isEqual: isEqual$1 = isEqual } = options || {}, defineStore = useContext(defineStoreContext), params = useQueryParams(queryParams), noStore = useMemo(
    () => ({
      subscribe: () => () => {
      },
      getSnapshot: () => initialData
    }),
    [initialData]
  ), store = useMemo(
    () => defineStore?.(initialData, query, params) || {
      subscribe: () => () => {
      },
      getSnapshot: () => initialData
    },
    [defineStore, initialData, params, query]
  ), [serverSnapshot] = useState(() => {
    if (initialData === void 0)
      throw new Error(
        "initialSnapshot can't be undefined, if you don't want an initial value use null instead"
      );
    try {
      return JSON.parse(JSON.stringify(initialData));
    } catch (error) {
      return console.warn(
        "Failed to deep clone initialSnapshot, this is likely an error and an indication that the snapshot isn't JSON serializable",
        { initialSnapshot: initialData, error }
      ), initialData;
    }
  }), getServerSnapshot = useCallback(() => serverSnapshot, [serverSnapshot]), selector = useCallback((snapshot2) => snapshot2, []), snapshot = useSyncExternalStoreWithSelector(
    store?.subscribe || noStore.subscribe,
    store?.getSnapshot || noStore.getSnapshot,
    getServerSnapshot,
    selector,
    isEqual$1
  ), enabled = defineStore !== null;
  return [snapshot, enabled && serverSnapshot === snapshot, enabled];
}
function useIsEnabled() {
  return useContext(defineStoreContext) !== null;
}
function useQueryParams(params) {
  const stringifiedParams = useMemo(() => JSON.stringify(params || {}), [params]);
  return useMemo(() => JSON.parse(stringifiedParams), [stringifiedParams]);
}
function useShouldPause() {
  const [online, setOnline] = useState(!1);
  useEffect(() => {
    setOnline(navigator.onLine);
    const online2 = () => setOnline(!0), offline = () => setOnline(!1);
    return window.addEventListener("online", online2), window.addEventListener("offline", offline), () => {
      window.removeEventListener("online", online2), window.removeEventListener("offline", offline);
    };
  }, []);
  const visibilityState = useSyncExternalStore(
    onVisibilityChange,
    () => document.visibilityState,
    () => "hidden"
  );
  return !online || visibilityState === "hidden";
}
function onVisibilityChange(onStoreChange) {
  return document.addEventListener("visibilitychange", onStoreChange), () => document.removeEventListener("visibilitychange", onStoreChange);
}
export {
  defineStoreContext,
  isEqual,
  useIsEnabled,
  useLiveQuery,
  useQueryParams,
  useShouldPause
};
//# sourceMappingURL=hooks.js.map
